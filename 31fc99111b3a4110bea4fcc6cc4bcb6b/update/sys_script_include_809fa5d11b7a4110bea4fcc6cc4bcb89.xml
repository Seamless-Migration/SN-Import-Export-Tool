<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.CSVtoJSON</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description/>
        <name>CSVtoJSON</name>
        <script><![CDATA[var CSVtoJSON = Class.create();
CSVtoJSON.prototype = {
    initialize: function() {
		
	},
	
	/*
		@parm1 : sys_id of attachment 
		return : JSON from CSV;
		reference : https://stackoverflow.com/questions/1293147/javascript-code-to-parse-csv-data
	*/

    getJSONFromCSVFile: function(sysId) {

        var attachmentGr = this.getAttachmentGR(sysId);

        if (JSUtil.nil(attachmentGr)) {
            return;
        }

        var gsa = new GlideSysAttachment();
        var bytesInFile = gsa.getBytes(attachmentGr.table_name, attachmentGr.table_sys_id);
        var dataAsString = Packages.java.lang.String(bytesInFile);

        dataAsString = String(dataAsString);
        return this.getCSVtoJSON(dataAsString);

    },

    getCSVtoJSON: function(strData, strDelimiter) {
        strDelimiter = (JSUtil.nil(strDelimiter)) ? "," : strDelimiter;
        gs.print(strDelimiter);
        // Create a regular expression to parse the CSV values.
        var objPattern = new RegExp(
            (
                // Delimiters.
                "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +
                // Quoted fields.
                "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
                // Standard fields.
                "([^\"\\" + strDelimiter + "\\r\\n]*))"
            ),
            "gi"
        );
        var arrMatches = null;
  
        gs.print(arrMatches);
        var dataObject = [];
        var headers = [];
        var rowCount = 0;
        var overAllElementsCount = 0;
        var columnCount = 0;
        var isHeaderBuilt = false;
        var rowInformation = {};
		// Keep looping over the regular expression matches
        // until we can no longer find a match.
        while (arrMatches = objPattern.exec(strData)) {
            // Get the delimiter that was found.
            var strMatchedValue = '';
            var strMatchedDelimiter = arrMatches[1];
            // Check to see if the given delimiter has a length
            // (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know
            // that this delimiter is a row delimiter.
            if (strMatchedDelimiter.length && (strMatchedDelimiter != strDelimiter)) {
                // Since we have reached a new row of data,
                // add an empty row to our data array.
                // reset column count and initialize the rowInformation object
                isHeaderBuilt = true;
                columnCount = 0;
                rowInformation = {};
            }
            // Now that we have our delimiter out of the way,
            // let's check to see which kind of value we
            // captured (quoted or unquoted).

            if (arrMatches[2]) {
                // We found a quoted value. When we capture
                // this value, unescape any double quotes.
                strMatchedValue = arrMatches[2].replace(new RegExp("\"\"", "g"), "\"");
            } else {
                // We found a non-quoted value.
                strMatchedValue = arrMatches[3];
            }

            //Build keys based on header row
            if (!isHeaderBuilt) {
                headers.push(strMatchedValue);
            }
            // Once header is built, now start creating object for each row
            if (isHeaderBuilt) {
                // If column count reaches last key in header
                if (columnCount == headers.length - 1) {
                    dataObject.push(rowInformation);
                }
                gs.print(" strMatchedValue " + strMatchedValue);
                if (JSUtil.nil(strMatchedValue)) {
                    rowInformation[headers[columnCount]] = '';
                } else {
                    rowInformation[headers[columnCount]] = strMatchedValue;
                }
                //gs.print(JSON.stringify(rowInformation, null, 4));
            }

            columnCount++;
        }
        // Return the parsed data.
      
        return dataObject;
    },

    getAttachmentGR: function(sysId) {

        var gr = new GlideRecord("sys_attachment");
        gr.addQuery("sys_id", sysId);
        gr.query();

        if (gr.next()) {
            return gr;
        }
        return;
    },

    type: 'CSVtoJSON'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>kyle.cribbs</sys_created_by>
        <sys_created_on>2022-04-10 17:56:31</sys_created_on>
        <sys_id>809fa5d11b7a4110bea4fcc6cc4bcb89</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>CSVtoJSON</sys_name>
        <sys_package display_value="Import/Export Tool" source="31fc99111b3a4110bea4fcc6cc4bcb6b">31fc99111b3a4110bea4fcc6cc4bcb6b</sys_package>
        <sys_policy/>
        <sys_scope display_value="Import/Export Tool">31fc99111b3a4110bea4fcc6cc4bcb6b</sys_scope>
        <sys_update_name>sys_script_include_809fa5d11b7a4110bea4fcc6cc4bcb89</sys_update_name>
        <sys_updated_by>kyle.cribbs</sys_updated_by>
        <sys_updated_on>2022-04-10 17:56:31</sys_updated_on>
    </sys_script_include>
</record_update>
